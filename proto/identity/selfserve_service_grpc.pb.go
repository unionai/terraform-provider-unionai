// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: identity/selfserve_service.proto

package identity

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	SelfServe_Register_FullMethodName                    = "/cloudidl.identity.SelfServe/Register"
	SelfServe_DeRegister_FullMethodName                  = "/cloudidl.identity.SelfServe/DeRegister"
	SelfServe_Offboard_FullMethodName                    = "/cloudidl.identity.SelfServe/Offboard"
	SelfServe_Provision_FullMethodName                   = "/cloudidl.identity.SelfServe/Provision"
	SelfServe_Update_FullMethodName                      = "/cloudidl.identity.SelfServe/Update"
	SelfServe_BatchUpdate_FullMethodName                 = "/cloudidl.identity.SelfServe/BatchUpdate"
	SelfServe_ProvisionOrg_FullMethodName                = "/cloudidl.identity.SelfServe/ProvisionOrg"
	SelfServe_ProvisionDataplaneResources_FullMethodName = "/cloudidl.identity.SelfServe/ProvisionDataplaneResources"
)

// SelfServeClient is the client API for SelfServe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SelfServeClient interface {
	Register(ctx context.Context, in *SelfServeRegisterRequest, opts ...grpc.CallOption) (*SelfServeRegisterResponse, error)
	// DeRegister is used to deregister a service from the selfserve system and uses the same input as Register.
	DeRegister(ctx context.Context, in *SelfServeDeregisterRequest, opts ...grpc.CallOption) (*SelfServeDeregisterResponse, error)
	// Offboard is used for offboarding the user and currently this gives the user Viewer permissions in his own org.
	Offboard(ctx context.Context, in *SelfServeRegisterRequest, opts ...grpc.CallOption) (*SelfServeRegisterResponse, error)
	// Provision is used to provision a users resources and not change their state
	Provision(ctx context.Context, in *SelfServeProvisionRequest, opts ...grpc.CallOption) (*SelfServeProvisionResponse, error)
	// Update is used to change the state of the user and not provision any resources
	Update(ctx context.Context, in *SelfServeUpdateRequest, opts ...grpc.CallOption) (*SelfServeUpdateResponse, error)
	// BatchUpdate is used to update multiple users at once
	BatchUpdate(ctx context.Context, in *SelfServeBatchUpdateRequest, opts ...grpc.CallOption) (*SelfServeBatchUpdateResponse, error)
	ProvisionOrg(ctx context.Context, in *SelfServeProvisionOrgRequest, opts ...grpc.CallOption) (*SelfServeProvisionOrgResponse, error)
	ProvisionDataplaneResources(ctx context.Context, in *SelfServeProvisionDataplaneResourcesRequest, opts ...grpc.CallOption) (*SelfServeProvisionDataplaneResourcesResponse, error)
}

type selfServeClient struct {
	cc grpc.ClientConnInterface
}

func NewSelfServeClient(cc grpc.ClientConnInterface) SelfServeClient {
	return &selfServeClient{cc}
}

func (c *selfServeClient) Register(ctx context.Context, in *SelfServeRegisterRequest, opts ...grpc.CallOption) (*SelfServeRegisterResponse, error) {
	out := new(SelfServeRegisterResponse)
	err := c.cc.Invoke(ctx, SelfServe_Register_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *selfServeClient) DeRegister(ctx context.Context, in *SelfServeDeregisterRequest, opts ...grpc.CallOption) (*SelfServeDeregisterResponse, error) {
	out := new(SelfServeDeregisterResponse)
	err := c.cc.Invoke(ctx, SelfServe_DeRegister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *selfServeClient) Offboard(ctx context.Context, in *SelfServeRegisterRequest, opts ...grpc.CallOption) (*SelfServeRegisterResponse, error) {
	out := new(SelfServeRegisterResponse)
	err := c.cc.Invoke(ctx, SelfServe_Offboard_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *selfServeClient) Provision(ctx context.Context, in *SelfServeProvisionRequest, opts ...grpc.CallOption) (*SelfServeProvisionResponse, error) {
	out := new(SelfServeProvisionResponse)
	err := c.cc.Invoke(ctx, SelfServe_Provision_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *selfServeClient) Update(ctx context.Context, in *SelfServeUpdateRequest, opts ...grpc.CallOption) (*SelfServeUpdateResponse, error) {
	out := new(SelfServeUpdateResponse)
	err := c.cc.Invoke(ctx, SelfServe_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *selfServeClient) BatchUpdate(ctx context.Context, in *SelfServeBatchUpdateRequest, opts ...grpc.CallOption) (*SelfServeBatchUpdateResponse, error) {
	out := new(SelfServeBatchUpdateResponse)
	err := c.cc.Invoke(ctx, SelfServe_BatchUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *selfServeClient) ProvisionOrg(ctx context.Context, in *SelfServeProvisionOrgRequest, opts ...grpc.CallOption) (*SelfServeProvisionOrgResponse, error) {
	out := new(SelfServeProvisionOrgResponse)
	err := c.cc.Invoke(ctx, SelfServe_ProvisionOrg_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *selfServeClient) ProvisionDataplaneResources(ctx context.Context, in *SelfServeProvisionDataplaneResourcesRequest, opts ...grpc.CallOption) (*SelfServeProvisionDataplaneResourcesResponse, error) {
	out := new(SelfServeProvisionDataplaneResourcesResponse)
	err := c.cc.Invoke(ctx, SelfServe_ProvisionDataplaneResources_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SelfServeServer is the server API for SelfServe service.
// All implementations should embed UnimplementedSelfServeServer
// for forward compatibility
type SelfServeServer interface {
	Register(context.Context, *SelfServeRegisterRequest) (*SelfServeRegisterResponse, error)
	// DeRegister is used to deregister a service from the selfserve system and uses the same input as Register.
	DeRegister(context.Context, *SelfServeDeregisterRequest) (*SelfServeDeregisterResponse, error)
	// Offboard is used for offboarding the user and currently this gives the user Viewer permissions in his own org.
	Offboard(context.Context, *SelfServeRegisterRequest) (*SelfServeRegisterResponse, error)
	// Provision is used to provision a users resources and not change their state
	Provision(context.Context, *SelfServeProvisionRequest) (*SelfServeProvisionResponse, error)
	// Update is used to change the state of the user and not provision any resources
	Update(context.Context, *SelfServeUpdateRequest) (*SelfServeUpdateResponse, error)
	// BatchUpdate is used to update multiple users at once
	BatchUpdate(context.Context, *SelfServeBatchUpdateRequest) (*SelfServeBatchUpdateResponse, error)
	ProvisionOrg(context.Context, *SelfServeProvisionOrgRequest) (*SelfServeProvisionOrgResponse, error)
	ProvisionDataplaneResources(context.Context, *SelfServeProvisionDataplaneResourcesRequest) (*SelfServeProvisionDataplaneResourcesResponse, error)
}

// UnimplementedSelfServeServer should be embedded to have forward compatible implementations.
type UnimplementedSelfServeServer struct {
}

func (UnimplementedSelfServeServer) Register(context.Context, *SelfServeRegisterRequest) (*SelfServeRegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedSelfServeServer) DeRegister(context.Context, *SelfServeDeregisterRequest) (*SelfServeDeregisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeRegister not implemented")
}
func (UnimplementedSelfServeServer) Offboard(context.Context, *SelfServeRegisterRequest) (*SelfServeRegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Offboard not implemented")
}
func (UnimplementedSelfServeServer) Provision(context.Context, *SelfServeProvisionRequest) (*SelfServeProvisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Provision not implemented")
}
func (UnimplementedSelfServeServer) Update(context.Context, *SelfServeUpdateRequest) (*SelfServeUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedSelfServeServer) BatchUpdate(context.Context, *SelfServeBatchUpdateRequest) (*SelfServeBatchUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdate not implemented")
}
func (UnimplementedSelfServeServer) ProvisionOrg(context.Context, *SelfServeProvisionOrgRequest) (*SelfServeProvisionOrgResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProvisionOrg not implemented")
}
func (UnimplementedSelfServeServer) ProvisionDataplaneResources(context.Context, *SelfServeProvisionDataplaneResourcesRequest) (*SelfServeProvisionDataplaneResourcesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProvisionDataplaneResources not implemented")
}

// UnsafeSelfServeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SelfServeServer will
// result in compilation errors.
type UnsafeSelfServeServer interface {
	mustEmbedUnimplementedSelfServeServer()
}

func RegisterSelfServeServer(s grpc.ServiceRegistrar, srv SelfServeServer) {
	s.RegisterService(&SelfServe_ServiceDesc, srv)
}

func _SelfServe_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelfServeRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SelfServeServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SelfServe_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SelfServeServer).Register(ctx, req.(*SelfServeRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SelfServe_DeRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelfServeDeregisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SelfServeServer).DeRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SelfServe_DeRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SelfServeServer).DeRegister(ctx, req.(*SelfServeDeregisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SelfServe_Offboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelfServeRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SelfServeServer).Offboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SelfServe_Offboard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SelfServeServer).Offboard(ctx, req.(*SelfServeRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SelfServe_Provision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelfServeProvisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SelfServeServer).Provision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SelfServe_Provision_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SelfServeServer).Provision(ctx, req.(*SelfServeProvisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SelfServe_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelfServeUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SelfServeServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SelfServe_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SelfServeServer).Update(ctx, req.(*SelfServeUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SelfServe_BatchUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelfServeBatchUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SelfServeServer).BatchUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SelfServe_BatchUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SelfServeServer).BatchUpdate(ctx, req.(*SelfServeBatchUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SelfServe_ProvisionOrg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelfServeProvisionOrgRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SelfServeServer).ProvisionOrg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SelfServe_ProvisionOrg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SelfServeServer).ProvisionOrg(ctx, req.(*SelfServeProvisionOrgRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SelfServe_ProvisionDataplaneResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelfServeProvisionDataplaneResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SelfServeServer).ProvisionDataplaneResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SelfServe_ProvisionDataplaneResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SelfServeServer).ProvisionDataplaneResources(ctx, req.(*SelfServeProvisionDataplaneResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SelfServe_ServiceDesc is the grpc.ServiceDesc for SelfServe service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SelfServe_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloudidl.identity.SelfServe",
	HandlerType: (*SelfServeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _SelfServe_Register_Handler,
		},
		{
			MethodName: "DeRegister",
			Handler:    _SelfServe_DeRegister_Handler,
		},
		{
			MethodName: "Offboard",
			Handler:    _SelfServe_Offboard_Handler,
		},
		{
			MethodName: "Provision",
			Handler:    _SelfServe_Provision_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _SelfServe_Update_Handler,
		},
		{
			MethodName: "BatchUpdate",
			Handler:    _SelfServe_BatchUpdate_Handler,
		},
		{
			MethodName: "ProvisionOrg",
			Handler:    _SelfServe_ProvisionOrg_Handler,
		},
		{
			MethodName: "ProvisionDataplaneResources",
			Handler:    _SelfServe_ProvisionDataplaneResources_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "identity/selfserve_service.proto",
}
