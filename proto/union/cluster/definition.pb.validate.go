// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: cluster/definition.proto

package cluster

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Spec with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Spec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Spec with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SpecMultiError, or nil if none found.
func (m *Spec) ValidateAll() error {
	return m.validate(true)
}

func (m *Spec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for AssignedConfigId

	if len(errors) > 0 {
		return SpecMultiError(errors)
	}

	return nil
}

// SpecMultiError is an error wrapping multiple validation errors returned by
// Spec.ValidateAll() if the designated constraints aren't met.
type SpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpecMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpecMultiError) AllErrors() []error { return m }

// SpecValidationError is the validation error returned by Spec.Validate if the
// designated constraints aren't met.
type SpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpecValidationError) ErrorName() string { return "SpecValidationError" }

// Error satisfies the builtin error interface
func (e SpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpecValidationError{}

// Validate checks the field values on SyncedConfigInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SyncedConfigInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncedConfigInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncedConfigInfoMultiError, or nil if none found.
func (m *SyncedConfigInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncedConfigInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConfigId

	if all {
		switch v := interface{}(m.GetSyncedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SyncedConfigInfoValidationError{
					field:  "SyncedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SyncedConfigInfoValidationError{
					field:  "SyncedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSyncedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SyncedConfigInfoValidationError{
				field:  "SyncedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SyncedConfigInfoMultiError(errors)
	}

	return nil
}

// SyncedConfigInfoMultiError is an error wrapping multiple validation errors
// returned by SyncedConfigInfo.ValidateAll() if the designated constraints
// aren't met.
type SyncedConfigInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncedConfigInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncedConfigInfoMultiError) AllErrors() []error { return m }

// SyncedConfigInfoValidationError is the validation error returned by
// SyncedConfigInfo.Validate if the designated constraints aren't met.
type SyncedConfigInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncedConfigInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncedConfigInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncedConfigInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncedConfigInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncedConfigInfoValidationError) ErrorName() string { return "SyncedConfigInfoValidationError" }

// Error satisfies the builtin error interface
func (e SyncedConfigInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncedConfigInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncedConfigInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncedConfigInfoValidationError{}

// Validate checks the field values on Status with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Status) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Status with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StatusMultiError, or nil if none found.
func (m *Status) ValidateAll() error {
	return m.validate(true)
}

func (m *Status) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Health

	if all {
		switch v := interface{}(m.GetCapabilities()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "Capabilities",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "Capabilities",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCapabilities()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusValidationError{
				field:  "Capabilities",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUnionOperatorInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "UnionOperatorInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "UnionOperatorInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUnionOperatorInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusValidationError{
				field:  "UnionOperatorInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPropellerInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "PropellerInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "PropellerInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPropellerInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusValidationError{
				field:  "PropellerInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetSecureTunnel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "SecureTunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "SecureTunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecureTunnel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusValidationError{
				field:  "SecureTunnel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSnapshotAggregate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "SnapshotAggregate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "SnapshotAggregate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSnapshotAggregate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusValidationError{
				field:  "SnapshotAggregate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMonitoringInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StatusValidationError{
						field:  fmt.Sprintf("MonitoringInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StatusValidationError{
						field:  fmt.Sprintf("MonitoringInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StatusValidationError{
					field:  fmt.Sprintf("MonitoringInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOperatorClusterData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "OperatorClusterData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "OperatorClusterData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorClusterData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusValidationError{
				field:  "OperatorClusterData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSyncedConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "SyncedConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "SyncedConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSyncedConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusValidationError{
				field:  "SyncedConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StatusMultiError(errors)
	}

	return nil
}

// StatusMultiError is an error wrapping multiple validation errors returned by
// Status.ValidateAll() if the designated constraints aren't met.
type StatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatusMultiError) AllErrors() []error { return m }

// StatusValidationError is the validation error returned by Status.Validate if
// the designated constraints aren't met.
type StatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatusValidationError) ErrorName() string { return "StatusValidationError" }

// Error satisfies the builtin error interface
func (e StatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatusValidationError{}

// Validate checks the field values on SecureTunnel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecureTunnel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecureTunnel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecureTunnelMultiError, or
// nil if none found.
func (m *SecureTunnel) ValidateAll() error {
	return m.validate(true)
}

func (m *SecureTunnel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Status

	// no validation rules for PublicUrl

	if len(errors) > 0 {
		return SecureTunnelMultiError(errors)
	}

	return nil
}

// SecureTunnelMultiError is an error wrapping multiple validation errors
// returned by SecureTunnel.ValidateAll() if the designated constraints aren't met.
type SecureTunnelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecureTunnelMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecureTunnelMultiError) AllErrors() []error { return m }

// SecureTunnelValidationError is the validation error returned by
// SecureTunnel.Validate if the designated constraints aren't met.
type SecureTunnelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecureTunnelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecureTunnelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecureTunnelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecureTunnelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecureTunnelValidationError) ErrorName() string { return "SecureTunnelValidationError" }

// Error satisfies the builtin error interface
func (e SecureTunnelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecureTunnel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecureTunnelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecureTunnelValidationError{}

// Validate checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ClusterMultiError, or nil if none found.
func (m *Cluster) ValidateAll() error {
	return m.validate(true)
}

func (m *Cluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPools() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterValidationError{
						field:  fmt.Sprintf("Pools[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterValidationError{
						field:  fmt.Sprintf("Pools[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterValidationError{
					field:  fmt.Sprintf("Pools[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClusterMultiError(errors)
	}

	return nil
}

// ClusterMultiError is an error wrapping multiple validation errors returned
// by Cluster.ValidateAll() if the designated constraints aren't met.
type ClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterMultiError) AllErrors() []error { return m }

// ClusterValidationError is the validation error returned by Cluster.Validate
// if the designated constraints aren't met.
type ClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterValidationError) ErrorName() string { return "ClusterValidationError" }

// Error satisfies the builtin error interface
func (e ClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterValidationError{}

// Validate checks the field values on Resources with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resources) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resources with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourcesMultiError, or nil
// if none found.
func (m *Resources) ValidateAll() error {
	return m.validate(true)
}

func (m *Resources) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CpuUnscaled

	// no validation rules for MemoryMega

	// no validation rules for StorageMega

	// no validation rules for EphemeralStorageMega

	// no validation rules for GpuUnscaled

	// no validation rules for AdditionalResources

	if len(errors) > 0 {
		return ResourcesMultiError(errors)
	}

	return nil
}

// ResourcesMultiError is an error wrapping multiple validation errors returned
// by Resources.ValidateAll() if the designated constraints aren't met.
type ResourcesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourcesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourcesMultiError) AllErrors() []error { return m }

// ResourcesValidationError is the validation error returned by
// Resources.Validate if the designated constraints aren't met.
type ResourcesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourcesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourcesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourcesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourcesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourcesValidationError) ErrorName() string { return "ResourcesValidationError" }

// Error satisfies the builtin error interface
func (e ResourcesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResources.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourcesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourcesValidationError{}

// Validate checks the field values on Capabilities with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Capabilities) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Capabilities with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CapabilitiesMultiError, or
// nil if none found.
func (m *Capabilities) ValidateAll() error {
	return m.validate(true)
}

func (m *Capabilities) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResources()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CapabilitiesValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CapabilitiesValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResources()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CapabilitiesValidationError{
				field:  "Resources",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExecutionLoad()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CapabilitiesValidationError{
					field:  "ExecutionLoad",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CapabilitiesValidationError{
					field:  "ExecutionLoad",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutionLoad()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CapabilitiesValidationError{
				field:  "ExecutionLoad",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PropellerConfigVersion

	if m.K8SPluginConfig != nil {

		if all {
			switch v := interface{}(m.GetK8SPluginConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CapabilitiesValidationError{
						field:  "K8SPluginConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CapabilitiesValidationError{
						field:  "K8SPluginConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetK8SPluginConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CapabilitiesValidationError{
					field:  "K8SPluginConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CapabilitiesMultiError(errors)
	}

	return nil
}

// CapabilitiesMultiError is an error wrapping multiple validation errors
// returned by Capabilities.ValidateAll() if the designated constraints aren't met.
type CapabilitiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CapabilitiesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CapabilitiesMultiError) AllErrors() []error { return m }

// CapabilitiesValidationError is the validation error returned by
// Capabilities.Validate if the designated constraints aren't met.
type CapabilitiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CapabilitiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CapabilitiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CapabilitiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CapabilitiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CapabilitiesValidationError) ErrorName() string { return "CapabilitiesValidationError" }

// Error satisfies the builtin error interface
func (e CapabilitiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCapabilities.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CapabilitiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CapabilitiesValidationError{}

// Validate checks the field values on ClusterResources with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClusterResources) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterResources with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterResourcesMultiError, or nil if none found.
func (m *ClusterResources) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterResources) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCapacity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterResourcesValidationError{
					field:  "Capacity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterResourcesValidationError{
					field:  "Capacity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCapacity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterResourcesValidationError{
				field:  "Capacity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConsumed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterResourcesValidationError{
					field:  "Consumed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterResourcesValidationError{
					field:  "Consumed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsumed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterResourcesValidationError{
				field:  "Consumed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterResourcesMultiError(errors)
	}

	return nil
}

// ClusterResourcesMultiError is an error wrapping multiple validation errors
// returned by ClusterResources.ValidateAll() if the designated constraints
// aren't met.
type ClusterResourcesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterResourcesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterResourcesMultiError) AllErrors() []error { return m }

// ClusterResourcesValidationError is the validation error returned by
// ClusterResources.Validate if the designated constraints aren't met.
type ClusterResourcesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterResourcesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterResourcesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterResourcesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterResourcesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterResourcesValidationError) ErrorName() string { return "ClusterResourcesValidationError" }

// Error satisfies the builtin error interface
func (e ClusterResourcesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterResources.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterResourcesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterResourcesValidationError{}

// Validate checks the field values on ExecutionLoad with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecutionLoad) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLoad with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExecutionLoadMultiError, or
// nil if none found.
func (m *ExecutionLoad) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLoad) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ActiveExecutionsCount

	// no validation rules for ActiveNodeExecutionsCount

	// no validation rules for ActiveTaskExecutionsCount

	if len(errors) > 0 {
		return ExecutionLoadMultiError(errors)
	}

	return nil
}

// ExecutionLoadMultiError is an error wrapping multiple validation errors
// returned by ExecutionLoad.ValidateAll() if the designated constraints
// aren't met.
type ExecutionLoadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLoadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLoadMultiError) AllErrors() []error { return m }

// ExecutionLoadValidationError is the validation error returned by
// ExecutionLoad.Validate if the designated constraints aren't met.
type ExecutionLoadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLoadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLoadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLoadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLoadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLoadValidationError) ErrorName() string { return "ExecutionLoadValidationError" }

// Error satisfies the builtin error interface
func (e ExecutionLoadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLoad.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLoadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLoadValidationError{}

// Validate checks the field values on ContainerTerminationInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContainerTerminationInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainerTerminationInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContainerTerminationInfoMultiError, or nil if none found.
func (m *ContainerTerminationInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainerTerminationInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExitCode

	// no validation rules for Signal

	// no validation rules for Reason

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetStartedRunningAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerTerminationInfoValidationError{
					field:  "StartedRunningAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerTerminationInfoValidationError{
					field:  "StartedRunningAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedRunningAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerTerminationInfoValidationError{
				field:  "StartedRunningAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinishedRunningAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerTerminationInfoValidationError{
					field:  "FinishedRunningAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerTerminationInfoValidationError{
					field:  "FinishedRunningAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinishedRunningAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerTerminationInfoValidationError{
				field:  "FinishedRunningAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContainerTerminationInfoMultiError(errors)
	}

	return nil
}

// ContainerTerminationInfoMultiError is an error wrapping multiple validation
// errors returned by ContainerTerminationInfo.ValidateAll() if the designated
// constraints aren't met.
type ContainerTerminationInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerTerminationInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerTerminationInfoMultiError) AllErrors() []error { return m }

// ContainerTerminationInfoValidationError is the validation error returned by
// ContainerTerminationInfo.Validate if the designated constraints aren't met.
type ContainerTerminationInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerTerminationInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerTerminationInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerTerminationInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerTerminationInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerTerminationInfoValidationError) ErrorName() string {
	return "ContainerTerminationInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ContainerTerminationInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainerTerminationInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerTerminationInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerTerminationInfoValidationError{}

// Validate checks the field values on ContainerInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ContainerInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainerInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainerInfoMultiError, or
// nil if none found.
func (m *ContainerInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainerInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Image

	if all {
		switch v := interface{}(m.GetStartedRunningAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerInfoValidationError{
					field:  "StartedRunningAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerInfoValidationError{
					field:  "StartedRunningAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedRunningAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerInfoValidationError{
				field:  "StartedRunningAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RestartCount

	if all {
		switch v := interface{}(m.GetLastTerminationInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerInfoValidationError{
					field:  "LastTerminationInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerInfoValidationError{
					field:  "LastTerminationInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastTerminationInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerInfoValidationError{
				field:  "LastTerminationInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContainerInfoMultiError(errors)
	}

	return nil
}

// ContainerInfoMultiError is an error wrapping multiple validation errors
// returned by ContainerInfo.ValidateAll() if the designated constraints
// aren't met.
type ContainerInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerInfoMultiError) AllErrors() []error { return m }

// ContainerInfoValidationError is the validation error returned by
// ContainerInfo.Validate if the designated constraints aren't met.
type ContainerInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerInfoValidationError) ErrorName() string { return "ContainerInfoValidationError" }

// Error satisfies the builtin error interface
func (e ContainerInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainerInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerInfoValidationError{}

// Validate checks the field values on PodInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PodInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PodInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PodInfoMultiError, or nil if none found.
func (m *PodInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PodInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConfigChecksum

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PodInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PodInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PodInfoValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMainContainerInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PodInfoValidationError{
					field:  "MainContainerInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PodInfoValidationError{
					field:  "MainContainerInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMainContainerInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PodInfoValidationError{
				field:  "MainContainerInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Version

	if len(errors) > 0 {
		return PodInfoMultiError(errors)
	}

	return nil
}

// PodInfoMultiError is an error wrapping multiple validation errors returned
// by PodInfo.ValidateAll() if the designated constraints aren't met.
type PodInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodInfoMultiError) AllErrors() []error { return m }

// PodInfoValidationError is the validation error returned by PodInfo.Validate
// if the designated constraints aren't met.
type PodInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodInfoValidationError) ErrorName() string { return "PodInfoValidationError" }

// Error satisfies the builtin error interface
func (e PodInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodInfoValidationError{}

// Validate checks the field values on PodGroup with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PodGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PodGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PodGroupMultiError, or nil
// if none found.
func (m *PodGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *PodGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPodInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodGroupValidationError{
						field:  fmt.Sprintf("PodInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodGroupValidationError{
						field:  fmt.Sprintf("PodInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodGroupValidationError{
					field:  fmt.Sprintf("PodInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PodGroupMultiError(errors)
	}

	return nil
}

// PodGroupMultiError is an error wrapping multiple validation errors returned
// by PodGroup.ValidateAll() if the designated constraints aren't met.
type PodGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodGroupMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodGroupMultiError) AllErrors() []error { return m }

// PodGroupValidationError is the validation error returned by
// PodGroup.Validate if the designated constraints aren't met.
type PodGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodGroupValidationError) ErrorName() string { return "PodGroupValidationError" }

// Error satisfies the builtin error interface
func (e PodGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodGroupValidationError{}

// Validate checks the field values on FlyteMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlyteMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlyteMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlyteMetadataMultiError, or
// nil if none found.
func (m *FlyteMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *FlyteMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Project

	// no validation rules for Domain

	if len(errors) > 0 {
		return FlyteMetadataMultiError(errors)
	}

	return nil
}

// FlyteMetadataMultiError is an error wrapping multiple validation errors
// returned by FlyteMetadata.ValidateAll() if the designated constraints
// aren't met.
type FlyteMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlyteMetadataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlyteMetadataMultiError) AllErrors() []error { return m }

// FlyteMetadataValidationError is the validation error returned by
// FlyteMetadata.Validate if the designated constraints aren't met.
type FlyteMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlyteMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlyteMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlyteMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlyteMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlyteMetadataValidationError) ErrorName() string { return "FlyteMetadataValidationError" }

// Error satisfies the builtin error interface
func (e FlyteMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlyteMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlyteMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlyteMetadataValidationError{}

// Validate checks the field values on ResourceSnapshot with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResourceSnapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceSnapshot with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceSnapshotMultiError, or nil if none found.
func (m *ResourceSnapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceSnapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nanocpu

	// no validation rules for Nanogpu

	// no validation rules for MemoryByte

	// no validation rules for Nanogpus

	if len(errors) > 0 {
		return ResourceSnapshotMultiError(errors)
	}

	return nil
}

// ResourceSnapshotMultiError is an error wrapping multiple validation errors
// returned by ResourceSnapshot.ValidateAll() if the designated constraints
// aren't met.
type ResourceSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceSnapshotMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceSnapshotMultiError) AllErrors() []error { return m }

// ResourceSnapshotValidationError is the validation error returned by
// ResourceSnapshot.Validate if the designated constraints aren't met.
type ResourceSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceSnapshotValidationError) ErrorName() string { return "ResourceSnapshotValidationError" }

// Error satisfies the builtin error interface
func (e ResourceSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceSnapshotValidationError{}

// Validate checks the field values on SnapshotAggregate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SnapshotAggregate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SnapshotAggregate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SnapshotAggregateMultiError, or nil if none found.
func (m *SnapshotAggregate) ValidateAll() error {
	return m.validate(true)
}

func (m *SnapshotAggregate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResourceInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SnapshotAggregateValidationError{
						field:  fmt.Sprintf("ResourceInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SnapshotAggregateValidationError{
						field:  fmt.Sprintf("ResourceInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SnapshotAggregateValidationError{
					field:  fmt.Sprintf("ResourceInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetStartAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SnapshotAggregateValidationError{
					field:  "StartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SnapshotAggregateValidationError{
					field:  "StartAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SnapshotAggregateValidationError{
				field:  "StartAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SnapshotAggregateValidationError{
					field:  "EndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SnapshotAggregateValidationError{
					field:  "EndAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SnapshotAggregateValidationError{
				field:  "EndAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SnapshotAggregateMultiError(errors)
	}

	return nil
}

// SnapshotAggregateMultiError is an error wrapping multiple validation errors
// returned by SnapshotAggregate.ValidateAll() if the designated constraints
// aren't met.
type SnapshotAggregateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnapshotAggregateMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnapshotAggregateMultiError) AllErrors() []error { return m }

// SnapshotAggregateValidationError is the validation error returned by
// SnapshotAggregate.Validate if the designated constraints aren't met.
type SnapshotAggregateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnapshotAggregateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnapshotAggregateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnapshotAggregateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnapshotAggregateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnapshotAggregateValidationError) ErrorName() string {
	return "SnapshotAggregateValidationError"
}

// Error satisfies the builtin error interface
func (e SnapshotAggregateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnapshotAggregate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnapshotAggregateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnapshotAggregateValidationError{}

// Validate checks the field values on ResourceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceInfoMultiError, or
// nil if none found.
func (m *ResourceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFlyteMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "FlyteMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "FlyteMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlyteMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "FlyteMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Used",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Used",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "Used",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAllocated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Allocated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Allocated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAllocated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "Allocated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBillableSecond()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "BillableSecond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "BillableSecond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBillableSecond()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "BillableSecond",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResourceInfoMultiError(errors)
	}

	return nil
}

// ResourceInfoMultiError is an error wrapping multiple validation errors
// returned by ResourceInfo.ValidateAll() if the designated constraints aren't met.
type ResourceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceInfoMultiError) AllErrors() []error { return m }

// ResourceInfoValidationError is the validation error returned by
// ResourceInfo.Validate if the designated constraints aren't met.
type ResourceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceInfoValidationError) ErrorName() string { return "ResourceInfoValidationError" }

// Error satisfies the builtin error interface
func (e ResourceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceInfoValidationError{}

// Validate checks the field values on IdentityInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IdentityInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IdentityInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IdentityInfoMultiError, or
// nil if none found.
func (m *IdentityInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *IdentityInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	if len(errors) > 0 {
		return IdentityInfoMultiError(errors)
	}

	return nil
}

// IdentityInfoMultiError is an error wrapping multiple validation errors
// returned by IdentityInfo.ValidateAll() if the designated constraints aren't met.
type IdentityInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IdentityInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IdentityInfoMultiError) AllErrors() []error { return m }

// IdentityInfoValidationError is the validation error returned by
// IdentityInfo.Validate if the designated constraints aren't met.
type IdentityInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IdentityInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IdentityInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IdentityInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IdentityInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IdentityInfoValidationError) ErrorName() string { return "IdentityInfoValidationError" }

// Error satisfies the builtin error interface
func (e IdentityInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIdentityInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IdentityInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IdentityInfoValidationError{}

// Validate checks the field values on OperatorClusterData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorClusterData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorClusterData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorClusterDataMultiError, or nil if none found.
func (m *OperatorClusterData) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorClusterData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for CloudHostName

	// no validation rules for MetadataBucketPrefix

	// no validation rules for BucketName

	// no validation rules for BucketRegion

	// no validation rules for UserRoleKey

	// no validation rules for UserRole

	// no validation rules for StorageType

	// no validation rules for GcpProjectId

	// no validation rules for CustomStorageConfig

	if len(errors) > 0 {
		return OperatorClusterDataMultiError(errors)
	}

	return nil
}

// OperatorClusterDataMultiError is an error wrapping multiple validation
// errors returned by OperatorClusterData.ValidateAll() if the designated
// constraints aren't met.
type OperatorClusterDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorClusterDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorClusterDataMultiError) AllErrors() []error { return m }

// OperatorClusterDataValidationError is the validation error returned by
// OperatorClusterData.Validate if the designated constraints aren't met.
type OperatorClusterDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorClusterDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorClusterDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorClusterDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorClusterDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorClusterDataValidationError) ErrorName() string {
	return "OperatorClusterDataValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorClusterDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorClusterData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorClusterDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorClusterDataValidationError{}

// Validate checks the field values on Status_MonitoringInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Status_MonitoringInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Status_MonitoringInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Status_MonitoringInfoMultiError, or nil if none found.
func (m *Status_MonitoringInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *Status_MonitoringInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Health

	// no validation rules for UnhealthyReason

	// no validation rules for ConsecutiveFailures

	if len(errors) > 0 {
		return Status_MonitoringInfoMultiError(errors)
	}

	return nil
}

// Status_MonitoringInfoMultiError is an error wrapping multiple validation
// errors returned by Status_MonitoringInfo.ValidateAll() if the designated
// constraints aren't met.
type Status_MonitoringInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Status_MonitoringInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Status_MonitoringInfoMultiError) AllErrors() []error { return m }

// Status_MonitoringInfoValidationError is the validation error returned by
// Status_MonitoringInfo.Validate if the designated constraints aren't met.
type Status_MonitoringInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Status_MonitoringInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Status_MonitoringInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Status_MonitoringInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Status_MonitoringInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Status_MonitoringInfoValidationError) ErrorName() string {
	return "Status_MonitoringInfoValidationError"
}

// Error satisfies the builtin error interface
func (e Status_MonitoringInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatus_MonitoringInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Status_MonitoringInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Status_MonitoringInfoValidationError{}
